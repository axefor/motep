# MTP_train

```Installation of mlippy, ikdtools```

contact **Yuji Ikeda** and **Axel forslund**

To run script

**mpirun -np 4 python3 main.py**

Require Module
```
import os
import sys
import time
import subprocess
import mlippy
from ikdtools.io.mlip.cfg import write_cfg, read_cfg
import numpy as np
import copy
from mpi4py import MPI
````
## Big Question ?
What This code do

-code loads CFG files and then calls write MTP file with random or custom unkown parameters and calculate energy,forces,stress
- write the function value (difference in weighted sum of energy,forces and stress between training set and current set based on current parameter)
- Uses python based optimization code to reduce the function value (errors)
- Can switch to different optimizer and any stage
- Can provide configurational weight to each atomic configurations









### Optimization algorithm

**Scipy modules :** ```BFGS, Nelder-mead, Differential evolution, Dual Annealing```

This repository also contains a Python implementation of a ```Genetic Algorithm (GA)``` for optimization problems. The GA is designed to find the optimal solution to a given problem by evolving a population of candidate solutions over multiple generations.
 #Genetic Algorithm Class




This class represents the Genetic Algorithm (GA) implementation. It has the following methods:

*__init__:* Initializes the GA with various parameters such as fitness function, population size, mutation rate, elitism rate, crossover probability, bounds for parameters, etc.

*initialize_population:* Generates an initial population of individuals with random parameters. 

*generate_random_parameter:* Generates a random parameter within specified bounds.

*crossover:* Performs crossover between two parents to generate offspring.

*mutate:* Performs mutation on an individual's parameter with a certain probability.

*select_elite:* Selects elite individuals based on their fitness scores.

```evolve_with_elites, evolve_with_common, evolve_with_mix, evolve_with_steady: Evolution methods using different strategies like elitism, common, mix, and steady-state.```

*optimization_GA Function:* This function is a wrapper for using the GA to optimize a target function. It takes the target function, initial guess for parameters, and any additional arguments. It initializes the GA instance with provided parameters and then runs the GA evolution process using one of the evolution methods (evolve_with_elites in this case).


*target_function:* This is an example of a target function that you would want to optimize. You need to define your own target function based on your optimization problem

 ### Elitism Evolution
- **Description**: This method preserves a certain percentage of the fittest individuals from each generation.
  - Elite individuals are directly copied to the next generation without undergoing crossover and mutation.
  - It helps maintain the best solutions found so far and can accelerate convergence.

### Common Evolution
- **Description**: In this method, selection for crossover and mutation is done from the entire population, not just the elite individuals.
  - Offspring are generated by selecting parents randomly from the entire population.
  - This method might introduce more diversity into the population, potentially exploring a wider range of solutions.

### Mix Evolution
- **Description**: This method combines elitism and common evolution strategies.
  - Elite individuals are preserved directly, while the rest of the population undergoes evolution with crossover and mutation.
  - The crossover operation is still performed between an elite individual and a randomly selected individual from the entire population.
  - This method aims to strike a balance between preserving good solutions and exploring new ones.

### Steady-State Evolution
- **Description**: In this method, the population evolves one individual at a time, maintaining a constant population size throughout evolution.
  - Elite individuals are selected and preserved, and the remaining individuals are replaced with offspring generated through crossover and mutation.
  - The replacement strategy ensures that the population size remains constant.
  - This method can be useful for problems where memory usage is a concern or when it's desirable to maintain a stable population size.



